mads 2.1.6
Source: loader.a65
     1 				    org $8000
     2
     3 = 0009			BOOT?  = $09
     4 = 000A			DOSVEC  = $0A
     5 = 004B			AEXTMEM = $4B
     6 = 00D8			MCBASE  = $D8
     7 = D301			PORTB   = $D301
     8
     9 				START:
    10 				; Detect Command Line
    11 				;     jsr detect_CMD
    12 				;     bne NoCMD
    13
    14 				;     jsr getParams
    15
    16 				; NoCMD:
    17
    18 				; ; Detect MIDICar
    19 				; step1:
    20 				;     jsr detect_MC
    21 				;     bcs MCNotFound
    22
    23 				; MCFound:
    24 				;     sty MCBASE
    25 				;     stx MCBASE+1
    26
    27 				;     jsr MCBASEPORT
    28
    29 				;     lda #<MIDICAR_EXIST
    30 				;     ldy #>MIDICAR_EXIST
    31 				;     jsr PRINT
    32
    33 				;     jmp step2
    34
    35 				; MCNotFound:
    36 				;     lda #$FF
    37 				;     sta MCBASE
    38 				;     lda #$00
    39 				;     sta MCBASE+1
    40 				;     lda #$02
    41 				;     sta $4ff
    42 				;     lda #<MIDICAR_NOT_FOUND
    43 				;     ldy #>MIDICAR_NOT_FOUND
    44 				;     jsr PRINT
    45
    46 				; SpartaDOS X detect
    47 				step2:
    48 FFFF> 8000-81CE> 20 6F +     jsr detect_sdx
    49 8003 C9 FF		    cmp #$ff
    50 8005 F0 0D		    beq step3
    51
    52 				; SDX user
    53
    54 8007 A9 BC		    lda #<SDX_FOUND
    55 8009 A0 81		    ldy #>SDX_FOUND
    56 800B 20 6F 81		    jsr PRINT
    57
    58 800E 20 3A 81		    jsr detect_xms_by_sdx
    59
    60 8011 4C 28 80		    jmp run_mcplay
    61
    62 				; extended RAM detection for non-SDX user
    63
    64 				; AXLON Memory extention detect
    65 8014			step3:
    66 8014 20 3B 80		    jsr detect_axlon
    67 8017 C0 00		    cpy #$00
    68 8019 F0 0A		    beq step4
    69 801B A9 94		    lda #<AXLON_FOUND
    70 801D A0 81		    ldy #>AXLON_FOUND
    71 801F 20 6F 81		    jsr PRINT
    72 8022 4C 38 80		    jmp exit2DOS
    73
    74 				; Determine extended memory size (PORTB based)
    75 8025			step4:
    76 8025 20 AD 80		    jsr detect_xms
    77
    78 8028			run_mcplay:
    79 8028 84 4B			sty AEXTMEM
    80
    81 802A A9 FE		    lda #$fe
    82 802C 8D 00 01		    sta $0100
    83
    84 				; Turn off BASIC
    85
    86 802F AD 01 D3		    lda PORTB
    87 8032 09 02		    ora #2
    88 8034 8D 01 D3		    sta PORTB
    89
    90 8037 60			    rts
    91
    92 8038			exit2DOS:
    93 8038 6C 0A 00		    jmp (DOSVEC)
    94
    95 				;
    96
    97 				    ; icl 'asm/detect_CMD.a65'
    98 				    ; icl 'asm/detect_mc.a65'
    99 803B			    icl 'asm/detect_axlon.a65'
Source: detect_axlon.a65
     1 = 4000			ext_b  = $4000       ;cokolwiek z zakresu $4000-$7FFF
     2 = CFFF			axlon  = $cfff
     3 = 0600			bsav   = $0600
     4
     5 				; procedura
     6 803B			detect_axlon
     7 803B A2 FF		       ldx #$ff      ;zapamiętanie bajtów ext
     8 803D 8E FF CF		_p0    stx axlon
     9 8040 AD 00 40		       lda ext_b
    10 8043 9D 00 06		       sta bsav,x
    11 8046 8E 00 40		       stx ext_b     ;oznaczenie bankow
    12 8049 CA			       dex           ;koniecznie w kolejnosci malejacej
    13 804A E0 FF		       cpx #$ff
    14 804C D0 EF		       bne _p0
    15
    16 804E E8			       inx
    17
    18 804F E8			_p1    inx           ;sprawdzenie numerow bankow
    19 8050 F0 08		       beq _x1
    20 8052 8E FF CF		       stx axlon
    21 8055 EC 00 40		       cpx ext_b
    22 8058 F0 F5		       beq _p1       ;pierwsza niezgodnosc przerywa petle
    23
    24 805A CA			_x1    dex           ;odliczamy bank podstawowy
    25 805B 8A			       txa
    26 805C A8			       tay
    27
    28 805D A2 00		       ldx #$00      ;przywrocenie wartosci
    29 805F 8E FF CF		_p2    stx axlon
    30 8062 BD 00 06		       lda bsav,x
    31 8065 8D 00 40		       sta ext_b
    32 8068 E8			       inx
    33 8069 D0 F4		       bne _p2
    34
    35 806B 8E FF CF		       stx axlon     ;ustaw bank podstawowy
    36 806E 60			       rts
   100 806F			    icl 'asm/detect_sdx.a65'
Source: detect_sdx.a65
     1 				; sparta_detect.asm
     2 				; (c) idea by KMK, code: mikey
     3 				;
     4 				; $Id: sparta_detect.asm,v 1.2 2006/09/27 22:59:27 mikey Exp $
     5 				;
     6
     7 = 000A			comtab  = $0A
     8 = 07EB			fsymbol = $07EB
     9
    10 = 00F0			T_      = $F0   ; pointer to SDX T_ symbol
    11 = 001D			_nbanks = $1D   ; COMTAB offset to free banks of extended memory
    12
    13 806F			detect_sdx
    14
    15 				; if peek($700) = 'S' and bit($701) sets V then we're SDX
    16
    17 806F AD 00 07		    lda $0700
    18 8072 C9 53		    cmp #$53         ; 'S'
    19 8074 D0 2C		    bne no_sparta
    20 8076 AD 01 07		    lda $0701
    21 8079 C9 40		    cmp #$40
    22 807B 90 25		    bcc no_sparta
    23 807D C9 44		    cmp #$44
    24 807F 90 0F		    bcc _oldsdx
    25
    26 				; we're running 4.4 - the old method is INVALID as of 4.42
    27
    28 8081 A9 A5		    lda #<sym_t
    29 8083 A2 80		    ldx #>sym_t
    30 8085 20 EB 07		    jsr fsymbol
    31 8088 85 F0		    sta T_
    32 808A 86 F1		    stx T_+1
    33 808C A0 06		    ldy #$06
    34 808E D0 0F		    bne _fv
    35
    36 				; we're running SDX, find (DOSVEC)-$150
    37
    38 8090			_oldsdx
    39 8090 A5 0A		    lda comtab
    40 8092 38			    sec
    41 8093 E9 50		    sbc #<$150
    42 8095 85 F0		    sta T_
    43 8097 A5 0B		    lda comtab+1
    44 8099 E9 01		    sbc #>$150
    45 809B 85 F1		    sta T_+1
    46
    47 				; ok, hopefully we have established the address.
    48 				; now peek at it. return the value.
    49
    50 809D A0 00		    ldy #0
    51 809F B1 F0		_fv lda (T_),y
    52 80A1 60			    rts
    53
    54 80A2			no_sparta
    55 80A2 A9 FF		    lda #$ff
    56 80A4 60			    rts
    57
    58 80A5			sym_t
    59 80A5 54 5F 20 20 20 20 +     .byte 'T_      '
    60 				;sym_comtab2
    61 				;    .byte 'COMTAB2 '
    62
    63 				; if A=$FF -> No SDX :(
    64 				; if A=$FE -> SDX is in OSROM mode
    65 				; if A=$00 -> SDX doesn't use any XMS banks
    66 				; if A=anything else -> BANKED mode, and A is the bank number
   101 80AD			    icl 'asm/detect_xms.a65'
Source: detect_xms.a65
     1 80AD			detect_xms:
     2
     3 80AD			    .local
     4
     5 = 0600			bsav	= $0600
     6 = 0101			banks   = $0101
     7 = 4000			ext_b	= $4000		;cokolwiek z zakresu $4000-$7FFF
     8 = D40B			vcount  = $D40B
     9 = D301			portb   = $D301
    10
    11 80AD 8A 48		    txa:pha
    12
    13 80AF AD 01 D3			lda portb
    14 80B2 48				pha
    15
    16 80B3 AD 0B D4 D0 FB		lda:rne vcount
    17
    18 80B8 AD 00 40			lda ext_b
    19 80BB 48				pha
    20
    21 80BC A2 0F			ldx #$0f	;zapamiętanie bajtów ext (z 16 bloków po 64k)
    22 80BE 20 2D 81		_p0	jsr setpb
    23 80C1 AD 00 40			lda ext_b
    24 80C4 9D 00 06			sta bsav,x
    25 80C7 CA				dex
    26 80C8 10 F4			bpl _p0
    27
    28 80CA A2 0F			ldx #$0f	;wyzerowanie ich (w oddzielnej pętli, bo nie wiadomo
    29 80CC 20 2D 81		_p1	jsr setpb	;które kombinacje bitów PORTB wybierają te same banki)
    30 80CF A9 00			lda #$00
    31 80D1 8D 00 40			sta ext_b
    32 80D4 CA				dex
    33 80D5 10 F5			bpl _p1
    34
    35 80D7 8E 01 D3			stx portb	;eliminacja pamięci podstawowej
    36 80DA 8E 00 40			stx ext_b
    37 80DD 86 00			stx $00		;niezbędne dla niektórych rozszerzeń do 256k
    38
    39 80DF A0 00			ldy #$00	;pętla zliczająca bloki 64k
    40 80E1 A2 0F			ldx #$0f
    41 80E3 20 2D 81		_p2	jsr setpb
    42 80E6 AD 00 40			lda ext_b	;jeśli ext_b jest różne od zera, blok 64k już zliczony
    43 80E9 D0 23			bne _n2
    44
    45 80EB CE 00 40			dec ext_b	;w przeciwnym wypadku zaznacz jako zliczony
    46
    47 80EE AD 00 40			lda ext_b	;sprawdz, czy sie zaznaczyl; jesli nie -> cos nie tak ze sprzetem
    48 80F1 10 1B			bpl _n2
    49
    50 80F3 AD 01 D3			lda portb	;wpisz wartość PORTB do tablicy dla banku 0
    51
    52 80F6 29 FE			and #$fe
    53
    54 80F8 99 01 01			sta banks,y
    55 80FB 49 04			eor #%00000100	;uzupełnij wartości dla banków 1, 2, 3
    56 80FD 99 02 01			sta banks+1,y
    57 8100 49 0C			eor #%00001100
    58 8102 99 03 01			sta banks+2,y
    59 8105 49 04			eor #%00000100
    60 8107 99 04 01			sta banks+3,y
    61 810A C8				iny
    62 810B C8				iny
    63 810C C8				iny
    64 810D C8				iny
    65
    66 810E CA			_n2	dex
    67 810F 10 D2			bpl _p2
    68
    69 8111 A2 0F			ldx #$0f	;przywrócenie zawartości ext
    70 8113 20 2D 81		_p3	jsr setpb
    71 8116 BD 00 06			lda bsav,x
    72 8119 8D 00 40			sta ext_b
    73 811C CA				dex
    74 811D 10 F4			bpl _p3
    75
    76 811F 8E 01 D3			stx portb	;X=$FF
    77
    78 8122 68				pla
    79 8123 8D 00 40			sta ext_b
    80
    81 8126 68				pla
    82 8127 8D 01 D3			sta portb
    83
    84 812A 68 AA		stop	pla:tax
    85
    86 812C 60				rts
    87
    88 				; podprogramy
    89 812D 8A			setpb	txa		;zmiana kolejności bitów: %0000dcba -> %cba000d0
    90 812E 4A				lsr
    91 812F 6A				ror
    92 8130 6A				ror
    93 8131 6A				ror
    94 8132 69 01			adc #$01	;ustawienie bitu nr 1 w zaleznosci od stanu C
    95 8134 09 01			ora #$01	;ustawienie bitu sterującego OS ROM na wartosc domyslna
    96 8136 8D 01 D3			sta portb
    97 8139 60				rts
    98
    99 				    .endl
   102 813A			    icl 'asm/detect_xms_by_sdx.a65'
Source: detect_xms_by_sdx.a65
     1 813A			detect_xms_by_sdx:
     2
     3 813A			    .local
     4 				; extended RAM detect by SDX
     5
     6 				; incrase T_ pointer to the beginig table of portb calulation
     7
     8 813A A5 F0		    lda T_
     9 813C 18 69 07		    add #$08-1
    10 813F 85 F0		    sta T_
    11 8141 A5 F1		    lda T_+1
    12 8143 69 00		    adc #$00
    13 8145 85 F1		    sta T_+1
    14
    15 				; get free banks
    16 8147 A0 1D		    ldy #_nbanks
    17 8149 B1 0A		    lda (comtab),y
    18 814B 18 69 04		    add #4
    19 814E 85 4B		    sta AEXTMEM
    20
    21 				; get values of port_b for free banks
    22
    23 8150 A2 04		    ldx #4
    24
    25 8152 8A			l1  txa
    26 8153 48			    pha
    27 8154 4A			    lsr
    28 8155 4A			    lsr
    29 8156 A8			    tay
    30 8157 68			    pla
    31 8158 29 03		    and #$03
    32 815A 0A			    asl
    33 815B 0A			    asl
    34 815C 11 F0		    ora (T_),y
    35
    36 815E 29 FE		    and #$fe
    37 8160 9D FD 00		    sta.w $00fd,x
    38
    39 8163 E8			    inx
    40 8164 E4 4B		    cpx AEXTMEM
    41 8166 30 EA		    bmi l1
    42
    43 8168 A5 4B		    lda AEXTMEM
    44 816A 38 E9 04		    sub #4
    45 816D A8			    tay
    46
    47 816E 60			    rts
    48
    49 				    .endl
   103 816F			    icl 'asm/print.a65'
Source: print.a65
     1 816F			PRINT:
     2
     3 816F			    .local
     4
     5 = 0340			ICCHID  = $0340
     6 = 0342			ICCMD   = $0342
     7 = 0344			ICBUFA  = $0344
     8 = 0348			ICBUFL  = $0348
     9 = E456			CIOV    = $E456
    10
    11 816F A2 00		    ldx #$00
    12 8171 9D 44 03		    sta ICBUFA,X
    13 8174 98			    tya
    14 8175 9D 45 03		    sta ICBUFA+1,X
    15 8178 A9 FF		    lda #$ff
    16 817A 9D 48 03		    sta ICBUFL,X
    17 817D A9 09		    lda #$09
    18 817F 9D 42 03		    sta ICCMD,X
    19 8182 BD 40 03		    lda ICCHID,x
    20 8185 30 03		    bmi ExitPRINT
    21 8187 4C 56 E4		    jmp CIOV
    22 818A			ExitPRINT:
    23 818A 60			    rts
    24
    25 				    .endl
   104 				    ; icl 'asm/16bit2hex.a65'
   105 				    ; icl 'asm/get_params.a65'
   106
   107 				//
   108 				//
   109
   110 				; Strings
   111 818B			MSG_NO_DOS:
   112 818B 4E 65 65 64 20 44 +     dta c'Need DOS',$9B
   113 				; MIDICAR_EXIST:
   114 				;     dta 'Yoppie! MIDICar found at $'
   115 				; MIDICAR_BASE:
   116 				;     dta 'xxxx',$9b
   117 				; MIDICAR_NOT_FOUND:
   118 				;     dta 'Ouch! MIDICar not found :(',$9B
   119 8194			AXLON_FOUND:
   120 8194 4F 68 2C 20 41 58 +     dta 'Oh, AXLON extention is not supported :(',$9B
   121 81BC			SDX_FOUND:
   122 81BC 53 44 58 20 75 73 +     dta 'SDX user. Oh yeah!',$9B
   123 				; HEX:
   124 				;     dta '0123456789abcdef'
   125 = 81CF			parbuf  equ *
   126
   127 02E2-02E3> 00 80		    ini START
